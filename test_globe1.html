<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>PhotoSearch Globe Mock</title>
    <style>
      :root {
        --bg0: #050a14;
        --bg1: #071026;
        --panel: rgba(255, 255, 255, 0.06);
        --panel2: rgba(255, 255, 255, 0.08);
        --stroke: rgba(255, 255, 255, 0.1);
        --text: rgba(255, 255, 255, 0.86);
        --muted: rgba(255, 255, 255, 0.58);
        --accent: rgba(90, 180, 255, 0.95);
        --accent2: rgba(255, 210, 120, 0.95);
        --shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
        --r: 18px;
      }

      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial;
        color: var(--text);
        background: radial-gradient(
            1200px 900px at 50% 20%,
            rgba(70, 120, 255, 0.08),
            transparent 60%
          ),
          radial-gradient(
            900px 700px at 70% 70%,
            rgba(255, 180, 80, 0.06),
            transparent 55%
          ),
          linear-gradient(180deg, var(--bg0), var(--bg1));
        height: 100vh;
        overflow: hidden;
      }

      .frame {
        position: relative;
        width: min(1600px, 96vw);
        height: min(920px, 92vh);
        margin: 3vh auto;
        border-radius: 26px;
        border: 1px solid var(--stroke);
        background: rgba(0, 0, 0, 0.2);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      /* top bar */
      .topbar {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        height: 70px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        pointer-events: none;
        z-index: 10;
      }

      .search {
        pointer-events: auto;
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 14px;
        border-radius: 999px;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.06);
        backdrop-filter: blur(10px);
        min-width: 420px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      }

      .pill {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 7px 10px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.18);
        border: 1px solid rgba(255, 255, 255, 0.08);
        color: var(--muted);
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .search input {
        flex: 1;
        background: transparent;
        border: 0;
        outline: none;
        color: var(--text);
        font-size: 14px;
      }
      .search input::placeholder {
        color: rgba(255, 255, 255, 0.35);
      }

      /* right rail filters */
      .rail {
        position: absolute;
        top: 88px;
        right: 16px;
        width: 270px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 10;
      }

      .card {
        border-radius: var(--r);
        background: rgba(255, 255, 255, 0.055);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        overflow: hidden;
      }
      .card .hd {
        padding: 10px 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: rgba(255, 255, 255, 0.75);
        font-size: 12px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }
      .card .bd {
        padding: 10px 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 10px 10px;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.16);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      .toggle .meta {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .toggle .meta b {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.86);
        font-weight: 600;
      }
      .toggle .meta span {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.55);
      }
      .switch {
        width: 44px;
        height: 26px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(255, 255, 255, 0.06);
        position: relative;
        cursor: pointer;
        flex: 0 0 auto;
      }
      .switch::after {
        content: '';
        width: 20px;
        height: 20px;
        border-radius: 999px;
        position: absolute;
        top: 50%;
        left: 3px;
        transform: translateY(-50%);
        background: rgba(255, 255, 255, 0.7);
        transition: left 220ms ease, background 220ms ease;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
      }
      .switch.on {
        background: rgba(90, 180, 255, 0.2);
        border-color: rgba(90, 180, 255, 0.35);
      }
      .switch.on::after {
        left: 21px;
        background: rgba(90, 180, 255, 0.95);
      }

      /* bottom timeline */
      .timeline {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        bottom: 16px;
        width: min(900px, 92%);
        z-index: 10;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .tlbar {
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(255, 255, 255, 0.055);
        backdrop-filter: blur(10px);
        padding: 12px 12px;
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .btn {
        height: 34px;
        min-width: 34px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.18);
        color: rgba(255, 255, 255, 0.85);
        cursor: pointer;
      }
      .btn:active {
        transform: translateY(1px);
      }
      .range {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      input[type='range'] {
        width: 100%;
      }
      .year {
        width: 86px;
        text-align: right;
        font-variant-numeric: tabular-nums;
        color: rgba(255, 255, 255, 0.78);
        font-size: 13px;
      }
      .hint {
        color: rgba(255, 255, 255, 0.55);
        font-size: 12px;
        padding-left: 10px;
      }

      /* canvas layer */
      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
      }

      /* tooltip */
      .tip {
        position: absolute;
        pointer-events: none;
        opacity: 0;
        transform: translate(-50%, calc(-100% - 10px));
        transition: opacity 120ms ease;
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(10, 14, 28, 0.8);
        backdrop-filter: blur(10px);
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
        width: max-content;
        max-width: 260px;
        z-index: 20;
      }
      .tip b {
        display: block;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.92);
        margin-bottom: 2px;
      }
      .tip span {
        display: block;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.65);
      }
      .tip.show {
        opacity: 1;
      }

      /* right side results drawer (mock) */
      .drawer {
        position: absolute;
        top: 88px;
        left: 16px;
        width: 340px;
        bottom: 92px;
        z-index: 10;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }
      .ph {
        aspect-ratio: 1 / 1;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: radial-gradient(
            90px 70px at 30% 25%,
            rgba(255, 255, 255, 0.12),
            transparent 60%
          ),
          radial-gradient(
            90px 80px at 70% 75%,
            rgba(255, 255, 255, 0.09),
            transparent 55%
          ),
          rgba(0, 0, 0, 0.14);
      }
      .small {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.6);
      }
    </style>
  </head>
  <body>
    <div class="frame" id="frame">
      <canvas id="globe"></canvas>

      <div class="topbar">
        <div class="search">
          <div class="pill">Search</div>
          <input
            id="q"
            placeholder="Try: beach, wedding, advay, bengaluru, 2022…"
          />
          <div class="pill" id="modePill">Location density</div>
        </div>
      </div>

      <div class="drawer">
        <div class="card">
          <div class="hd">
            <span>Selection</span>
            <span class="small" id="selMeta">None</span>
          </div>
          <div class="bd">
            <div class="small" id="selDesc">
              Hover clusters. Click to “open” a place (mock).
            </div>
          </div>
        </div>

        <div class="card">
          <div class="hd">
            <span>Results</span>
            <span class="small" id="resMeta">0 photos</span>
          </div>
          <div class="bd">
            <div class="grid" id="grid"></div>
            <div class="small" id="gridHint">
              This is a dummy grid to show the interaction pattern.
            </div>
          </div>
        </div>
      </div>

      <div class="rail">
        <div class="card">
          <div class="hd">
            <span>Layers</span
            ><span class="small" id="layerMeta">1 active</span>
          </div>
          <div class="bd">
            <div class="toggle">
              <div class="meta">
                <b>Location density</b><span>Clusters and heat</span>
              </div>
              <div class="switch on" data-layer="density"></div>
            </div>
            <div class="toggle">
              <div class="meta">
                <b>Faces</b><span>Filter clusters by faces</span>
              </div>
              <div class="switch" data-layer="faces"></div>
            </div>
            <div class="toggle">
              <div class="meta">
                <b>Scenes</b><span>Beach, food, outdoors…</span>
              </div>
              <div class="switch" data-layer="scenes"></div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="hd">
            <span>Story mode</span><span class="small">Optional</span>
          </div>
          <div class="bd">
            <button class="btn" id="storyBtn" style="width: 100%">
              Play travel story
            </button>
            <div class="small">
              Auto-rotates + highlights major clusters over time.
            </div>
          </div>
        </div>
      </div>

      <div class="timeline">
        <div class="tlbar">
          <button class="btn" id="playBtn" title="Play/pause">▶</button>
          <div class="range">
            <input
              id="year"
              type="range"
              min="2016"
              max="2025"
              step="1"
              value="2022"
            />
          </div>
          <div class="year" id="yearLabel">2022</div>
        </div>
        <div class="hint" id="hint">
          Drag the year to see density shift. Hover to inspect clusters.
        </div>
      </div>

      <div class="tip" id="tip"></div>
    </div>

    <script>
      // ---- Canvas setup (responsive) ----
      const canvas = document.getElementById('globe');
      const ctx = canvas.getContext('2d');
      const frame = document.getElementById('frame');
      const tip = document.getElementById('tip');

      function resize() {
        const r = frame.getBoundingClientRect();
        canvas.width = Math.floor(r.width * devicePixelRatio);
        canvas.height = Math.floor(r.height * devicePixelRatio);
        canvas.style.width = r.width + 'px';
        canvas.style.height = r.height + 'px';
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      }
      window.addEventListener('resize', resize);
      resize();

      // ---- Synthetic dataset (replace with your real geo-index) ----
      // lat [-90..90], lon [-180..180], weight per year, name
      const clusters = [
        {
          name: 'Bengaluru',
          lat: 12.97,
          lon: 77.59,
          years: mkYears(2016, 2025, [20, 24, 28, 35, 44, 60, 72, 80, 92, 110]),
        },
        {
          name: 'Goa',
          lat: 15.49,
          lon: 73.83,
          years: mkYears(2016, 2025, [2, 3, 5, 7, 12, 18, 26, 20, 14, 10]),
        },
        {
          name: 'Delhi',
          lat: 28.61,
          lon: 77.21,
          years: mkYears(2016, 2025, [4, 5, 6, 6, 7, 10, 14, 18, 12, 9]),
        },
        {
          name: 'Singapore',
          lat: 1.35,
          lon: 103.82,
          years: mkYears(2016, 2025, [0, 0, 0, 0, 0, 0, 0, 30, 24, 14]),
        },
        {
          name: 'Dubai',
          lat: 25.2,
          lon: 55.27,
          years: mkYears(2016, 2025, [0, 0, 0, 6, 8, 10, 8, 6, 4, 2]),
        },
        {
          name: 'London',
          lat: 51.5,
          lon: -0.12,
          years: mkYears(2016, 2025, [0, 1, 2, 2, 1, 0, 0, 0, 0, 0]),
        },
        {
          name: 'New York',
          lat: 40.71,
          lon: -74.01,
          years: mkYears(2016, 2025, [0, 0, 0, 1, 2, 2, 1, 0, 0, 0]),
        },
        {
          name: 'Tokyo',
          lat: 35.68,
          lon: 139.69,
          years: mkYears(2016, 2025, [0, 0, 0, 0, 0, 2, 4, 3, 2, 1]),
        },
        {
          name: 'Bihar Sharif',
          lat: 25.2,
          lon: 85.52,
          years: mkYears(2016, 2025, [6, 8, 10, 12, 14, 16, 18, 22, 26, 20]),
        },
      ];

      function mkYears(minY, maxY, arr) {
        const m = {};
        let i = 0;
        for (let y = minY; y <= maxY; y++) {
          m[y] = arr[i++] ?? 0;
        }
        return m;
      }

      // Extra “noise” points to make density feel real
      const extra = [];
      for (let i = 0; i < 160; i++) {
        extra.push({
          name: '(cluster)',
          lat: rand(-60, 70),
          lon: rand(-180, 180),
          years: mkRandomYears(2016, 2025),
        });
      }
      function mkRandomYears(minY, maxY) {
        const m = {};
        for (let y = minY; y <= maxY; y++) {
          // Sparse by default
          m[y] =
            Math.random() < 0.78
              ? 0
              : Math.floor(Math.pow(Math.random(), 2.2) * 10);
        }
        return m;
      }

      const all = clusters.concat(extra);

      // ---- UI state ----
      const yearEl = document.getElementById('year');
      const yearLabel = document.getElementById('yearLabel');
      const playBtn = document.getElementById('playBtn');
      const storyBtn = document.getElementById('storyBtn');
      const modePill = document.getElementById('modePill');
      const layerMeta = document.getElementById('layerMeta');

      const selMeta = document.getElementById('selMeta');
      const selDesc = document.getElementById('selDesc');
      const resMeta = document.getElementById('resMeta');
      const grid = document.getElementById('grid');

      const layers = { density: true, faces: false, scenes: false };
      let selected = null;

      let year = +yearEl.value;
      let t = 0; // time
      let rot = 0.0; // globe rotation (radians)
      let hovering = null;
      let playing = false;
      let storyPlaying = false;
      let storyIndex = 0;
      let storyTimer = 0;

      // ---- Interaction wiring ----
      yearEl.addEventListener('input', () => {
        year = +yearEl.value;
        yearLabel.textContent = year;
      });

      playBtn.addEventListener('click', () => {
        playing = !playing;
        playBtn.textContent = playing ? '❚❚' : '▶';
        storyPlaying = false;
        modePill.textContent = getModeLabel();
      });

      storyBtn.addEventListener('click', () => {
        storyPlaying = !storyPlaying;
        storyIndex = 0;
        storyTimer = 0;
        modePill.textContent = storyPlaying ? 'Travel story' : getModeLabel();
        playing = false;
        playBtn.textContent = '▶';
      });

      document.querySelectorAll('.switch').forEach((sw) => {
        sw.addEventListener('click', () => {
          const key = sw.dataset.layer;
          layers[key] = !layers[key];
          sw.classList.toggle('on', layers[key]);
          const active = Object.values(layers).filter(Boolean).length;
          layerMeta.textContent = active + ' active';
        });
      });

      canvas.addEventListener('mousemove', (e) => {
        const r = canvas.getBoundingClientRect();
        const mx = e.clientX - r.left;
        const my = e.clientY - r.top;
        hovering = hitTest(mx, my);
        if (hovering) {
          tip.innerHTML = `<b>${hovering.name}</b>
          <span>${fmt(hovering.count)} photos · ${hovering.range}</span>`;
          tip.style.left = mx + 'px';
          tip.style.top = my + 'px';
          tip.classList.add('show');
        } else {
          tip.classList.remove('show');
        }
      });

      canvas.addEventListener('mouseleave', () => {
        hovering = null;
        tip.classList.remove('show');
      });

      canvas.addEventListener('click', (e) => {
        const r = canvas.getBoundingClientRect();
        const mx = e.clientX - r.left;
        const my = e.clientY - r.top;
        const h = hitTest(mx, my);
        if (h && h.isPrimary) {
          selected = h;
          selMeta.textContent = h.name;
          selDesc.textContent = `${fmt(h.count)} photos • ${
            h.range
          } • click-year scrub affects density`;
          populateGrid(h.count);
        }
      });

      function populateGrid(n) {
        const count = Math.min(12, Math.max(6, Math.round(n / 12)));
        grid.innerHTML = '';
        for (let i = 0; i < count; i++) {
          const d = document.createElement('div');
          d.className = 'ph';
          grid.appendChild(d);
        }
        resMeta.textContent = `${fmt(n)} photos`;
      }

      function getModeLabel() {
        const active = [];
        if (layers.density) active.push('Location density');
        if (layers.faces) active.push('Faces');
        if (layers.scenes) active.push('Scenes');
        return active.length ? active[0] : 'Layers off';
      }

      // ---- Projection: sphere to screen (fake globe) ----
      function project(lat, lon, R, cx, cy, rot) {
        // Convert degrees to radians
        const phi = (lat * Math.PI) / 180; // latitude
        const lam = (lon * Math.PI) / 180; // longitude
        // Basic sphere coords
        // y is "up", z is "towards viewer"
        let x = Math.cos(phi) * Math.sin(lam);
        let y = Math.sin(phi);
        let z = Math.cos(phi) * Math.cos(lam);

        // rotate around y-axis (vertical) for globe spin
        const cr = Math.cos(rot),
          sr = Math.sin(rot);
        const x2 = x * cr + z * sr;
        const z2 = -x * sr + z * cr;

        // only show front hemisphere
        const visible = z2 > 0;

        // simple perspective projection
        const persp = 0.92 + 0.18 * z2;
        const sx = cx + x2 * R * persp;
        const sy = cy - y * R * persp;

        return { sx, sy, visible, z: z2, persp };
      }

      // ---- Rendering ----
      function draw() {
        const w = frame.clientWidth;
        const h = frame.clientHeight;
        ctx.clearRect(0, 0, w, h);

        // background stars
        drawStars(w, h);

        const cx = w * 0.52;
        const cy = h * 0.55;
        const R = Math.min(w, h) * 0.42;

        // globe body
        drawGlobeBase(cx, cy, R);

        // animate rotation
        if (playing) rot += 0.0045;
        else rot += 0.0012;

        // story mode: rotate + jump to major clusters over time
        if (storyPlaying) {
          storyTimer += 1 / 60;
          // advance year slowly
          if (storyTimer > 1.4) {
            storyTimer = 0;
            year = Math.min(2025, Math.max(2016, year + 1));
            yearEl.value = year;
            yearLabel.textContent = year;
            storyIndex = (storyIndex + 1) % clusters.length;
          }
          // rotate target towards selected cluster lon
          const target = clusters[storyIndex];
          const targetRot = (-target.lon * Math.PI) / 180; // crude
          rot += (targetRot - rot) * 0.02;
          modePill.textContent = `Travel story · ${year}`;
        } else {
          modePill.textContent = getModeLabel();
        }

        // compute counts for hit test + display
        const pts = [];
        for (const c of all) {
          const count = (c.years[year] || 0) * (c.name === '(cluster)' ? 1 : 1);
          if (count <= 0 && c.name === '(cluster)') continue;
          const p = project(c.lat, c.lon, R, cx, cy, rot);
          if (!p.visible) continue;

          const isPrimary = c.name !== '(cluster)';
          const range = yearRange(c.years);
          pts.push({
            ...p,
            name: c.name,
            count,
            isPrimary,
            range,
            lat: c.lat,
            lon: c.lon,
          });
        }

        // sort back to front for nicer overlap
        pts.sort((a, b) => a.z - b.z);

        // optional layer filters (mock behavior: change alpha)
        const facesBoost = layers.faces ? 1.0 : 0.0;
        const scenesBoost = layers.scenes ? 1.0 : 0.0;

        // draw heat / clusters
        if (layers.density) {
          for (const p of pts) {
            const s = Math.max(2, Math.sqrt(p.count) * 1.9);
            const a = clamp(0.06 + p.count * 0.006, 0.06, 0.28);
            const ring = p.isPrimary ? 1 : 0;

            // subtle heat blob
            radialDot(p.sx, p.sy, s * 6, a);

            // cluster core
            coreDot(p.sx, p.sy, s, a + 0.12, ring);

            // hint of other layers (just to show toggles are real)
            if (facesBoost && p.isPrimary) halo(p.sx, p.sy, s * 2.8, 0.1);
            if (scenesBoost && p.isPrimary) haloWarm(p.sx, p.sy, s * 3.1, 0.08);
          }
        }

        // hover highlight
        if (hovering) {
          pulse(hovering.sx, hovering.sy, 18);
        }
        // selection highlight
        if (selected) {
          // project selected each frame because rotation changes
          const sp = project(selected.lat, selected.lon, R, cx, cy, rot);
          if (sp.visible) {
            ring(sp.sx, sp.sy, 24, 0.18);
            ring(sp.sx, sp.sy, 34, 0.1);
          }
        }

        // globe edge
        ctx.beginPath();
        ctx.arc(cx, cy, R + 1.5, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255,255,255,0.10)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // cache for hit testing
        draw._pts = pts;

        requestAnimationFrame(draw);
      }

      // ---- Drawing helpers ----
      let starField = null;
      function drawStars(w, h) {
        if (!starField || starField.w !== w || starField.h !== h) {
          starField = { w, h, stars: [] };
          const n = Math.floor((w * h) / 18000);
          for (let i = 0; i < n; i++) {
            starField.stars.push({
              x: Math.random() * w,
              y: Math.random() * h,
              r: Math.random() * 1.3,
              a: 0.1 + Math.random() * 0.22,
            });
          }
        }
        ctx.fillStyle = 'rgba(255,255,255,0.0)';
        for (const s of starField.stars) {
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255,255,255,${s.a})`;
          ctx.fill();
        }
      }

      function drawGlobeBase(cx, cy, R) {
        // globe fill
        const g = ctx.createRadialGradient(
          cx - R * 0.25,
          cy - R * 0.25,
          R * 0.15,
          cx,
          cy,
          R
        );
        g.addColorStop(0, 'rgba(255,255,255,0.08)');
        g.addColorStop(0.45, 'rgba(255,255,255,0.03)');
        g.addColorStop(1, 'rgba(0,0,0,0.12)');
        ctx.beginPath();
        ctx.arc(cx, cy, R, 0, Math.PI * 2);
        ctx.fillStyle = g;
        ctx.fill();

        // terminator shading
        const g2 = ctx.createRadialGradient(
          cx + R * 0.25,
          cy + R * 0.05,
          R * 0.2,
          cx + R * 0.35,
          cy,
          R * 1.05
        );
        g2.addColorStop(0, 'rgba(0,0,0,0.00)');
        g2.addColorStop(0.55, 'rgba(0,0,0,0.18)');
        g2.addColorStop(1, 'rgba(0,0,0,0.55)');
        ctx.beginPath();
        ctx.arc(cx, cy, R, 0, Math.PI * 2);
        ctx.fillStyle = g2;
        ctx.fill();

        // subtle latitude lines
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, R, 0, Math.PI * 2);
        ctx.clip();
        for (let i = -60; i <= 60; i += 15) {
          const y = cy - (i / 90) * R * 0.82;
          ctx.beginPath();
          ctx.ellipse(cx, y, R * 0.86, R * 0.18, 0, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(255,255,255,0.03)';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        ctx.restore();
      }

      function radialDot(x, y, r, a) {
        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
        g.addColorStop(0, `rgba(90,180,255,${a})`);
        g.addColorStop(1, 'rgba(90,180,255,0)');
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = g;
        ctx.fill();
      }
      function coreDot(x, y, r, a, ringIt) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${clamp(a, 0.1, 0.65)})`;
        ctx.fill();
        if (ringIt) {
          ctx.beginPath();
          ctx.arc(x, y, r + 4, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(90,180,255,0.28)';
          ctx.lineWidth = 1.2;
          ctx.stroke();
        }
      }
      function halo(x, y, r, a) {
        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
        g.addColorStop(0, `rgba(90,180,255,${a})`);
        g.addColorStop(1, 'rgba(90,180,255,0)');
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = g;
        ctx.fill();
      }
      function haloWarm(x, y, r, a) {
        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
        g.addColorStop(0, `rgba(255,210,120,${a})`);
        g.addColorStop(1, 'rgba(255,210,120,0)');
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = g;
        ctx.fill();
      }
      function pulse(x, y, r) {
        const p = (Math.sin(t * 3.0) + 1) / 2; // 0..1
        ring(x, y, r + p * 10, 0.12);
        t += 1 / 60;
      }
      function ring(x, y, r, a) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(90,180,255,${a})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // ---- Hit testing ----
      function hitTest(mx, my) {
        const pts = draw._pts || [];
        // only primary points are interactable (cities)
        let best = null;
        let bestD = 1e9;
        for (const p of pts) {
          if (!p.isPrimary) continue;
          const d = Math.hypot(mx - p.sx, my - p.sy);
          const hitR = Math.max(10, Math.sqrt(p.count) * 2.3 + 10);
          if (d < hitR && d < bestD) {
            bestD = d;
            best = p;
          }
        }
        return best;
      }

      function yearRange(map) {
        const ys = Object.keys(map)
          .map(Number)
          .filter((y) => map[y] > 0)
          .sort((a, b) => a - b);
        if (!ys.length) return '—';
        if (ys.length === 1) return String(ys[0]);
        return `${ys[0]}–${ys[ys.length - 1]}`;
      }

      // ---- Utils ----
      function rand(a, b) {
        return a + Math.random() * (b - a);
      }
      function clamp(v, a, b) {
        return Math.max(a, Math.min(b, v));
      }
      function fmt(n) {
        if (n >= 1_000_000)
          return (n / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
        if (n >= 1_000) return (n / 1_000).toFixed(1).replace(/\.0$/, '') + 'k';
        return String(n);
      }

      // init dummy grid
      populateGrid(0);
      // render loop
      modePill.textContent = getModeLabel();
      yearLabel.textContent = year;
      draw();
    </script>
  </body>
</html>
